//
//  POIDetailPresenter.swift
//  LocatorApp
//
//  Created Ivan Cabezon on 22/8/18.
//  Copyright © 2018 Globile. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import MapKit

protocol POIDetailDelegate: class {
	func didTapOnPin(poiAnnotation: POIAnnotation, selected: Bool)
	func deselectPin(with selectedAnnotation: POIAnnotation)
	func handleOpenOrClose()
    func isOpen() -> Bool?
}


// MARK: Presenter -

protocol POIDetailPresenterProtocol: UITableViewDelegate, UITableViewDataSource {
    var showNearestPOI: Bool { get set }
	var detailDelegate: POIDetailDelegate? { get set }
	var lastKnownLocation: CLLocationCoordinate2D? { get set }
    var view: POIDetailViewProtocol? { get set }
    var mapViewHeightAndSearchBarContainerY: (viewHeight: CGFloat, searchBarContainerY: CGFloat)? { get set }
    
    func makeAppintment()
    func showMakeAppointment() -> Bool
	
	func setSelectedPOI(_ poi: POIAnnotation)
	func deselectPin()
    
    func viewDidLoad()

	func routeToPOIAction()
	func handleOpenOrClose()
    func getSchedule(from poi: POI) -> String
    func calculateRemainingHours(times: String?, isATM: Bool, completion: @escaping (_ showColor: UIColor, _ timeLeft:String)->())
	func getAttributtedStringFor(mainPoi poi: POI) -> NSAttributedString?
	func getAttributtedStringFor(secondaryPoiIn poi: POI) -> NSAttributedString?
    //This method is needed if change the schedule time version
    //func statusToClose(_ poi: POI) -> StatusTimeToClose
}

enum StatusTimeToClose {
    case open
    case close
    case closeSoon
}

class POIDetailPresenter: NSObject, POIDetailPresenterProtocol {
        
    var showNearestPOI: Bool = false
    var descriptionString: String = ""
	var lastKnownLocation: CLLocationCoordinate2D?
    var mapViewHeightAndSearchBarContainerY: (viewHeight: CGFloat, searchBarContainerY: CGFloat)?
	
    weak var view: POIDetailViewProtocol?
    var interactor: POIDetailInteractorProtocol?
    let router: POIDetailWireframeProtocol
	
	weak var detailDelegate: POIDetailDelegate?
    
    var mainPOISelected = true
	
    init(interface: POIDetailViewProtocol, interactor: POIDetailInteractorProtocol?, router: POIDetailWireframeProtocol) {
        self.view = interface
        self.interactor = interactor
        self.router = router
    }
	
	func viewDidLoad() {
		if let poi = interactor?.poi {
			view?.configureWith(mapPin: poi.mapPin)
		}
	}
	
    func showMakeAppointment() -> Bool {
        return interactor?.appointmentURL(for: mainPOISelected) != nil
    }
    
	func setSelectedPOI(_ poi: POIAnnotation) {
        mainPOISelected = true
		interactor?.poi = poi
	}
	
	func deselectPin() {
		if let poi = interactor?.poi {
			detailDelegate?.deselectPin(with: poi)
		}
	}
    
    func getSchedule(from poi: POI) -> String {
        var schedule: String = ""
        if let open = poi.schedule?.scheduleDayFrom(day: Calendar.current.component(.weekday, from: Date())) {
            _ = open.map({schedule.append($0)})
            
        }
        return schedule
    }
	
	func handleOpenOrClose() {
     
            self.detailDelegate?.handleOpenOrClose()

	}
	
	func getAttributtedStringFor(mainPoi poi: POI) -> NSAttributedString? {
		return interactor?.getAttributtedStringFor(mainPoi: poi)
	}
	
	func getAttributtedStringFor(secondaryPoiIn poi: POI) -> NSAttributedString? {
		return interactor?.getAttributtedStringFor(secondaryPoiIn: poi)
	}
	
    @objc func makeCall() {
		if let phone = interactor?.getPhone(for: mainPOISelected) {
			let phone = phone.replacingOccurrences(of: " ", with: "")
			if let url = URL(string: "tel://\(phone)") {
				if router.canOpenURL(url: url) {
					router.openURL(url: url)
					if mainPOISelected {
                        //  ANALYTICS REMOVED
//                        BLAnalyticsHandler.track(event: .tapOnCallButton,
//                                               screenName: BlEvent.detailView.rawValue,
//                                               with: [BlKeys.eventAction.rawValue:BlEvent.tapOnCallButton.rawValue,
//                                                      BlKeys.tabName.rawValue:Type.branch.rawValue],
//                                               isScreen: false)
					} else {
                        //  ANALYTICS REMOVED
//                        BLAnalyticsHandler.track(event: .tapOnCallButton,
//                                               screenName: BlEvent.detailView.rawValue,
//                                               with: [BlKeys.eventAction.rawValue:BlEvent.tapOnCallButton.rawValue,
//                                                      BlKeys.tabName.rawValue:Type.atm.rawValue],
//                                               isScreen: false)
					}
				}
			}
		}
    }
	
	@objc func makeAppintment() {
		if let appointmentURL = interactor?.appointmentURL(for: mainPOISelected) {
			if router.canOpenURL(url: appointmentURL) {
				router.openURL(url: appointmentURL)
                //AnalyticsHandler.track(event: .makeAppointment, isScreen: false)
			}
		}
	}
	
	func routeToPOIAction() {
		guard let mapPin = interactor?.poi?.mapPin else { return }
        
        if let isOpen = detailDelegate?.isOpen() {
            if isOpen {
                //  ANALYTICS REMOVED
//                BLAnalyticsHandler.track(event: .tapOpenMap,
//                                       screenName: BlEvent.detailView.rawValue,
//                                       with: [BlKeys.eventAction.rawValue: BlEvent.tapOpenMap.rawValue,
//                                              BlKeys.openMapOrigin.rawValue: BlEvent.detailView.rawValue,
//                                              BlKeys.branchATMType.rawValue: mapPin.objectType.code.analiticsValue,
//                                              BlKeys.branchATMName.rawValue: mapPin.name ?? "" as Any],
//                                       isScreen: false)
            } else {
                //  ANALYTICS REMOVED
//                BLAnalyticsHandler.track(event: .tapOpenMap,
//                                       screenName: BlEvent.detailView.rawValue,
//                                       with: [BlKeys.eventAction.rawValue: BlEvent.tapOpenMap.rawValue,
//                                              BlKeys.openMapOrigin.rawValue: BlEvent.homeView.rawValue,
//                                              BlKeys.branchATMType.rawValue: mapPin.objectType.code.analiticsValue,
//                                              BlKeys.branchATMName.rawValue: mapPin.name ?? "" as Any],
//                                       isScreen: false)
            }
        } else {
            //  ANALYTICS REMOVED
//            BLAnalyticsHandler.track(event: .tapOpenMap,
//                                   screenName: BlEvent.detailView.rawValue,
//                                   with: [BlKeys.eventAction.rawValue: BlEvent.tapOpenMap.rawValue,
//                                          BlKeys.branchATMType.rawValue: mapPin.objectType.code.analiticsValue,
//                                          BlKeys.branchATMName.rawValue: mapPin.name ?? "" as Any],
//                                   isScreen: false)
        }
        
        
        
		router.navigateToDestination(latitude: mapPin.geoLocation.latitude, longitude: mapPin.geoLocation.longitude)
	}
    
    
    func calculateRemainingHours(times: String?, isATM: Bool,completion: @escaping (_ showColor: UIColor, _ timeLeft: String)->()) {
        // some businesses only have one close time some two
        //para cajeros cuando no mandan nada es 24h
        guard let time = times else {return}
        if time.isEmpty {
            if isATM {
                let properties = colorLabelCoordinater(timeUntil: 62)
                completion(properties.0,properties.1)
            } else {
                let properties = colorLabelCoordinater(timeUntil: 0)
                completion(properties.0,properties.1)
            }
            return
        }
        //para evitar calcular minutos de cierre en los cajeros
        if time == "00:00-23:59" {
            let properties = colorLabelCoordinater(timeUntil: 62)
            completion(properties.0,properties.1)
            return
        }
        
        var timeStringsArray = [String]()
        var timesAsDatesArray = [Date]()
        
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm"
        formatter.timeZone = TimeZone.current
        
        // device time
        let stringDate = formatter.string(from: NSDate() as Date)
        let deviceTime = formatter.date(from: stringDate)!
        
        let seperateTimes = time.components(separatedBy: "\n")
        
        // seperate strings
        for timeSlots in seperateTimes {
            for timeSection in timeSlots.components(separatedBy: "-") {
                // now with the seperate times add to an array of time strings
                timeStringsArray.append(timeSection)
            }
        }
        
        // put all into dates
        for date in timeStringsArray {
            // turn strings into a date
            //comprobaciones para evitar crashes
            if let timesAsDate = formatter.date(from: date) {
                timesAsDatesArray.append(timesAsDate)
            } else if date == "24h" {
                let properties = colorLabelCoordinater(timeUntil: 62)
                completion(properties.0,properties.1)
                return
            } else {
                let properties = colorLabelCoordinater(timeUntil: -1)
                completion(properties.0,properties.1)
                return
            }
        }
        
        // array can contain a max of 4 values
        if timesAsDatesArray.count == 4 {
            // business has two opening and closing times
            if deviceTime < timesAsDatesArray[1] {
                // if user time is less than first closing time
                // then check if if user time is before first opening time
                if deviceTime < timesAsDatesArray[0] {
                    // is before opening time
                    let properties = colorLabelCoordinater(timeUntil: 0)
                    completion(properties.0,properties.1)
                } else {
                    let timeUntil = timesAsDatesArray[1].minutes(from: deviceTime)
                    let properties = colorLabelCoordinater(timeUntil: timeUntil)
                    completion(properties.0,properties.1)
                }
            } else if deviceTime < timesAsDatesArray[2] {
                // if now is before second opening time
                // it still hasnt opened from the first closing time
                let properties = colorLabelCoordinater(timeUntil: 0)
                completion(properties.0,properties.1)
            }else {
                if deviceTime < timesAsDatesArray[3] {
                    let timeUntil = timesAsDatesArray[3].minutes(from: deviceTime)
                    let properties = colorLabelCoordinater(timeUntil: timeUntil)
                    completion(properties.0,properties.1)
                } else {
                    // place is closed
                    let properties = colorLabelCoordinater(timeUntil: 0)
                    completion(properties.0,properties.1)
                }
            }
            
        } else {
            // business only has one opening and closing time
            if deviceTime < timesAsDatesArray[0] {
                // place hasnt opened yet
                let properties = colorLabelCoordinater(timeUntil: 0)
                completion(properties.0,properties.1)
            } else {
                // check if device time is before the closing date
                if deviceTime < timesAsDatesArray[1] {
                    let timeUntil = timesAsDatesArray[1].minutes(from: deviceTime)
                    let properties = colorLabelCoordinater(timeUntil: timeUntil)
                    completion(properties.0,properties.1)
                } else {
                    let properties = colorLabelCoordinater(timeUntil: 0)
                    completion(properties.0,properties.1)
                }
            }
            
        }
        
    }
    
    // TODO: localize these values closing in.
    func colorLabelCoordinater(timeUntil: Int) -> (UIColor, String) {
        var circleColor = UIColor()
        var timeLbl = ""
        
        switch timeUntil {
        case 0:
           circleColor = DetailCardCellAndViewThemeColor.closingLabelCircleViewRed.value
           timeLbl = localizedString("bl_closed")
        case 1...60:
            circleColor = DetailCardCellAndViewThemeColor.closingLabelCircleViewOrange.value
            timeLbl = String(format: localizedString("bl_closing_in"), timeUntil)
            break
        case 61...:
            circleColor = DetailCardCellAndViewThemeColor.closingLabelCircleViewGreen.value
            timeLbl = localizedString("bl_open_now")
            break
        case -1:
            circleColor = DetailCardCellAndViewThemeColor.closingLabelCircleViewRed.value
            timeLbl = localizedString("bl_closed")
            break
        default:
            circleColor = DetailCardCellAndViewThemeColor.closingLabelCircleViewGreen.value
            timeLbl = localizedString("bl_open_now")
            break
        }
        return (circleColor, timeLbl)
    }
    
}
extension Date {

    func minutes(from date: Date) -> Int {
        return Calendar.current.dateComponents([.minute], from: date, to: self).minute ?? 0
    }
}


extension POIDetailPresenter: UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        if let count = interactor?.countFullDetailElements(for: mainPOISelected) {
            return count
        } else {
            return 0
        }
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cellType = interactor?.getCellType(for: mainPOISelected, atIndexPath: indexPath)
		
		switch cellType! {
        case .openingUntil:
            if let cell = tableView.dequeueReusableCell(withIdentifier: OpeningHoursCell.nibString(), for: indexPath) as? OpeningHoursCell {
                if let poi = interactor?.poi?.mapPin {
                    if let code = poi.objectType?.code {
                        switch code {
                        case .atm:
                            configureClosingTimeCell(cell: cell, isATM: true)
                            
                        default:
                            configureClosingTimeCell(cell: cell, isATM: false)
                        }
                    } else {
                        configureClosingTimeCell(cell: cell, isATM: false)
                    }
                }
                cell.layoutMargins = UIEdgeInsets.zero
                return cell
            }
            
		case .phone:
			if let cell = tableView.dequeueReusableCell(withIdentifier: PhoneCell.nibString(), for: indexPath) as? PhoneCell {
				cell.titleLabel.text = interactor?.getPhoneTitle(for: mainPOISelected)
				cell.detailLabel.text = interactor?.getPhone(for: mainPOISelected)
				if interactor?.getPhone(for: mainPOISelected) != nil {
					cell.callButton.addTarget(self, action: #selector(makeCall), for: .touchUpInside)
					cell.callButton.isHidden = false
				} else {
					cell.callButton.removeTarget(self, action: #selector(makeCall), for: .touchUpInside)
					cell.callButton.isHidden = true
				}
                cell.layoutMargins = UIEdgeInsets.zero
				return cell
			}
		case .schedule:
			if let cell = tableView.dequeueReusableCell(withIdentifier: ScheduleTableViewCell.nibString(), for: indexPath) as? ScheduleTableViewCell {
                //cell.configure(with: interactor?.getSchedule(for: mainPOISelected))
				cell.configure(with: interactor?.getScheduleInCompounds(for: mainPOISelected))
                cell.layoutMargins = UIEdgeInsets.zero
				return cell
			}
            
        case .scheduleCash:
        if let cell = tableView.dequeueReusableCell(withIdentifier: ScheduleCashTableViewCell.nibString(), for: indexPath) as? ScheduleCashTableViewCell {
            //cell.configure(with: interactor?.getSchedule(for: mainPOISelected))
            cell.configure(with: interactor?.getScheduleCash(for: mainPOISelected))
            cell.layoutMargins = UIEdgeInsets.zero
            return cell
        }
   
		case .accesibility:
			if let cell = tableView.dequeueReusableCell(withIdentifier: AccessibilityTableViewCell.nibString(), for: indexPath) as? AccessibilityTableViewCell {
				cell.configure(withAudioguidanceTextVisible: interactor?.shouldShowAudioGuidanceInAccessibility(for: mainPOISelected) ?? false)
                cell.layoutMargins = UIEdgeInsets.zero
				return cell
			}
		case .news:
			if let cell = tableView.dequeueReusableCell(withIdentifier: NewsTableViewCell.nibString(), for: indexPath) as? NewsTableViewCell {
				if let interactor = interactor,
					let news = interactor.getNewsAndAditionalInfo(for: mainPOISelected) {
					cell.configure(with: news)
				}

                cell.layoutMargins = UIEdgeInsets.zero
                cell.delegate = self
				return cell
			}
		case .basicServices:
			if let cell = tableView.dequeueReusableCell(withIdentifier: BasicServicesTableViewCell.nibString(), for: indexPath) as? BasicServicesTableViewCell {
				cell.configure(with: interactor?.getBasicServices(for: mainPOISelected) ?? [])
                cell.layoutMargins = UIEdgeInsets.zero
				return cell
			}
		case .aditionalService:
			if let cell = tableView.dequeueReusableCell(withIdentifier: AdditionalServicesTableViewCell.nibString(), for: indexPath) as? AdditionalServicesTableViewCell {
				cell.configure(with: interactor?.getAdditionalServices(for: mainPOISelected))
                cell.layoutMargins = UIEdgeInsets.zero
				return cell
			}
		}
        
        assert(false)
        return UITableViewCell()
    }
    
    func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {
		return UITableView.automaticDimension
    }
        
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
		return UITableView.automaticDimension
	}
	
	func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
		if interactor?.hasRelatedAtm() ?? false {
            if let view = Bundle(for: MapViewController.self).branchLocatorBundle?.loadNibNamed("DetailButtonsSectionTableView", owner: self, options: nil)?.first as? DetailButtonsSectionTableView {
				view.delegate = self
				view.configureView(main: mainPOISelected)
                tableView.removeUnnecessaryHeaderTopPadding()
				return view
			}
			assert(false)
			return UIView()
		} else {
			return nil
		}
    }
    
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
		if interactor?.hasRelatedAtm() ?? false {
			return 50
        } else {
            return 0
        }
    }
    
    func configureClosingTimeCell(cell: OpeningHoursCell, isATM: Bool) {
        if let times = interactor?.getHoursForToday(isMainPOI: mainPOISelected) {
            calculateRemainingHours(times: times, isATM: isATM) { (showColor,timeLeft) in
                cell.configure(openingHours: timeLeft, circleColor: showColor)
            }
        }
    }
}

extension POIDetailPresenter: DetailSectionTableProtocol {
	func buttonPressed(left: Bool) {
        if left {
            if let poi = interactor?.poi?.mapPin {
                //  ANALYTICS REMOVED
//                BLAnalyticsHandler.track(event: .tapBranchDetail,
//                                       screenName: BlEvent.detailView.rawValue,
//                                       with: [BlKeys.eventAction.rawValue: BlEvent.tapBranchDetail.rawValue,
//                                              BlKeys.branchATMType.rawValue: poi.objectType.code.analiticsValue,
//                                              BlKeys.branchATMName.rawValue: poi.name ?? "" as Any,
//                                              BlKeys.tabName.rawValue: Type.branch.analiticsValue],
//                                       isScreen: false)
            }else{
                //  ANALYTICS REMOVED
//                BLAnalyticsHandler.track(event: .tapBranchDetail,
//                                       screenName: BlEvent.detailView.rawValue,
//                                       with: [BlKeys.eventAction.rawValue: BlEvent.tapBranchDetail.rawValue,
//                                              BlKeys.tabName.rawValue: Type.branch.analiticsValue],
//                                       isScreen: false)
            }
            
            mainPOISelected = true
        } else {
            if let poi = interactor?.poi?.mapPin {
                //  ANALYTICS REMOVED
//                BLAnalyticsHandler.track(event: .tapBranchDetail,
//                                       screenName: BlEvent.detailView.rawValue,
//                                       with: [BlKeys.eventAction.rawValue: BlEvent.tapBranchDetail.rawValue,
//                                              BlKeys.branchATMType.rawValue: poi.objectType.code.analiticsValue,
//                                              BlKeys.branchATMName.rawValue: poi.name ?? "" as Any,
//                                              BlKeys.tabName.rawValue: Type.atm.analiticsValue],
//                                       isScreen: false)
            }else{
                //  ANALYTICS REMOVED
//                BLAnalyticsHandler.track(event: .tapBranchPicker,
//                                       screenName: BlEvent.detailView.rawValue,
//                                       with: [BlKeys.eventAction.rawValue: BlEvent.tapBranchPicker.rawValue,
//                                              BlKeys.tabName.rawValue: Type.atm.analiticsValue],
//                                       isScreen: false)
            }
            mainPOISelected = false
        }
        view?.reloadTable()
    }
}

extension POIDetailPresenter: NewsTableViewCellProtocol {
    func openURL(_ url: URL) {
        if router.canOpenURL(url: url){
            router.openURL(url: url)
        }
    }
}

